LAB 1:

1:

CREATE TABLE MyTable (
    id NUMBER,
    val NUMBER
);

***********************************************************************************************************************
2:

DECLARE
    v_random_val NUMBER;
BEGIN
    FOR i IN 1..10000 LOOP
        v_random_val := ROUND(DBMS_RANDOM.VALUE * 100);
        INSERT INTO MyTable (id, val) VALUES (i, v_random_val);
    END LOOP;
    
    COMMIT;
END;

***********************************************************************************************************************

3:

CREATE OR REPLACE FUNCTION checkEvenOddCount(table_name IN VARCHAR2) RETURN VARCHAR2 IS
    v_even_count NUMBER := 0;
    v_odd_count NUMBER := 0;
BEGIN
    FOR rec IN (SELECT val FROM MyTable) LOOP
        IF MOD(rec.val, 2) = 0 THEN
            v_even_count := v_even_count + 1;
        ELSE
            v_odd_count := v_odd_count + 1;
        END IF;
    END LOOP;

    IF v_even_count > v_odd_count THEN
        RETURN 'TRUE';
    ELSIF v_even_count < v_odd_count THEN
        RETURN 'FALSE';
    ELSE
        RETURN 'EQUAL';
    END IF;
END;

SELECT checkEvenOddCount('MyTable') AS result FROM dual;

***********************************************************************************************************************
(функция для подсчета чет и нечет чисел)

CREATE OR REPLACE FUNCTION countEvenOdd(table_name IN VARCHAR2)
RETURN VARCHAR2 IS
    v_even_count NUMBER := 0;
    v_odd_count NUMBER := 0;
BEGIN
    FOR rec IN (SELECT val FROM MyTable) LOOP
        IF MOD(rec.val, 2) = 0 THEN
            v_even_count := v_even_count + 1;
        ELSE
            v_odd_count := v_odd_count + 1;
        END IF;
    END LOOP;

    RETURN 'Even Count: ' || TO_CHAR(v_even_count) || ', Odd Count: ' || TO_CHAR(v_odd_count);
END;

SELECT countEvenOdd('MyTable') AS result FROM dual;

***********************************************************************************************************************

4:

CREATE OR REPLACE FUNCTION generateInsertCommand(p_id IN NUMBER, p_val IN NUMBER)
RETURN VARCHAR2 IS
    v_insert_command VARCHAR2(4000);
BEGIN
    v_insert_command := 'INSERT INTO MyTable (id, val) VALUES (' || p_id || ', ' || p_val || ');';
    RETURN v_insert_command;
END;

SELECT generateInsertCommand(1001, 5 ) AS result FROM dual;


***********************************************************************************************************************

5:

CREATE OR REPLACE PROCEDURE insertRecord(
    p_id IN NUMBER,
    p_val IN NUMBER
)
IS
BEGIN
    INSERT INTO MyTable (id, val) VALUES (p_id, p_val);
    COMMIT;
END insertRecord;


CREATE OR REPLACE PROCEDURE updateRecord(
    p_id IN NUMBER,
    p_new_val IN NUMBER
)
IS
BEGIN
    UPDATE MyTable SET val = p_new_val WHERE id = p_id;
    COMMIT;
END updateRecord;



CREATE OR REPLACE PROCEDURE deleteRecord(
    p_id IN NUMBER
)
IS
BEGIN
    DELETE FROM MyTable WHERE id = p_id;
    COMMIT;
END deleteRecord;

EXECUTE insertRecord(2, 300); 
EXECUTE updateRecord(2, 400);
EXECUTE deleteRecord(2); 

SELECT *
FROM (
    SELECT *
    FROM MyTable
    ORDER BY id DESC
)
WHERE ROWNUM <= 10; -- выводит последние 10 строк

***********************************************************************************************************************
6:

CREATE OR REPLACE FUNCTION calculateTotalCompensation(
    p_monthly_salary IN NUMBER,
    p_annual_bonus_percent IN NUMBER
)
RETURN NUMBER
IS
    v_total_compensation NUMBER;
    v_annual_bonus_pct NUMBER; 
BEGIN
    IF p_annual_bonus_percent < 0 OR p_annual_bonus_percent > 100 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Ошибка: процент премии должен быть в диапазоне от 0 до 100.');
    END IF;

    v_annual_bonus_pct := p_annual_bonus_percent / 100;

    v_total_compensation := (1 + v_annual_bonus_pct) * 12 * p_monthly_salary;

    RETURN v_total_compensation;
END calculateTotalCompensation;
/


SELECT calculateTotalCompensation(1000, 5 ) AS result FROM dual;

***********************************************************************************************************************
***********************************************************************************************************************
***********************************************************************************************************************

LAB_02:

1:
CREATE TABLE Students (
    Id INT PRIMARY KEY,
    Name VARCHAR2(100),
    Group_id INT,
    FOREIGN KEY (Group_id) REFERENCES Groups(Id)
);

CREATE TABLE Groups (
    Id INT PRIMARY KEY,
    Name VARCHAR2(100),
    C_val INT
);

***********************************************************************************************************************
2:
-- Триггер для проверки уникальности полей ID в таблице Students
CREATE OR REPLACE TRIGGER check_student_id_unique 
BEFORE INSERT ON Students
FOR EACH ROW
DECLARE
    v_count NUMBER;
BEGIN
    SELECT COUNT(*)
    INTO v_count
    FROM Students
    WHERE Id = :NEW.Id;

    IF v_count > 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Ошибка: Поле ID должно быть уникальным в таблице Students.');
    END IF;
END;


INSERT INTO Students (Id, Name, Group_id) VALUES (1, 'dvdv', 1);


-- Триггер для генерации автоинкрементного ключа для поля ID в таблице Students
CREATE OR REPLACE TRIGGER generate_student_id
BEFORE INSERT ON Students
FOR EACH ROW
BEGIN
    IF :NEW.Id IS NULL THEN -- Проверяем, было ли указано значение Id во вставке
        :NEW.Id := Students_seq.NEXTVAL; -- Генерируем новое значение Id только если оно не указано явно
    END IF;
END;
/


INSERT INTO Students (Name, Group_id) VALUES ('Pavel', 1);
select * from students

-- Триггер для проверки уникальности полей ID в таблице Groups
CREATE OR REPLACE TRIGGER check_gruop_id_unique 
BEFORE INSERT ON Groups
FOR EACH ROW
DECLARE
    v_count NUMBER;
BEGIN
    SELECT COUNT(*)
    INTO v_count
    FROM Groups
    WHERE Id = :NEW.Id;

    IF v_count > 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Ошибка: Поле ID должно быть уникальным в таблице Groups.');
    END IF;
END;


INSERT INTO Groups (id, Name, C_val) VALUES (4, 'Group D', 10);


-- Триггер для генерации автоинкрементного ключа для поля ID в таблице Groups
CREATE SEQUENCE Groups_seq START WITH 1 INCREMENT BY 1;
CREATE OR REPLACE TRIGGER generate_Group_id
BEFORE INSERT ON Groups
FOR EACH ROW
BEGIN
    IF :NEW.Id IS NULL THEN -- Проверяем, было ли указано значение Id во вставке
        :NEW.Id := Groups_seq.NEXTVAL; -- Генерируем новое значение Id только если оно не указано явно
    END IF;
END;
/

INSERT INTO Groups (Name, C_val) VALUES ('Group great', 5);

create or replace NONEDITIONABLE TRIGGER check_group_name_unique
BEFORE INSERT ON Groups
FOR EACH ROW
DECLARE
    v_count NUMBER;
BEGIN
    SELECT COUNT(*)
    INTO v_count
    FROM Groups
    WHERE Name = :NEW.Name;

    IF v_count > 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Ошибка: Поле Name должно быть уникальным в таблице Groups.');
    END IF;
END;

INSERT INTO Groups (Name, C_val) VALUES ('Group gre', 5);


***********************************************************************************************************************
3:
--триггер, обеспечивающий внешний ключ с каскадным удалением между таблицами STUDENTS и GROUPS
CREATE OR REPLACE TRIGGER CASCADE_DELETE_STUDENTS
BEFORE DELETE ON GROUPS
FOR EACH ROW
BEGIN
    DELETE FROM STUDENTS
    WHERE Group_id = :OLD.Id;
END;
/


select * from groups;
select * from students;
DELETE FROM GROUPS WHERE Id = 2;
select * from groups;
select * from students;

***********************************************************************************************************************
4:

CREATE TABLE STUDENTS_LOG (
    log_id NUMBER GENERATED ALWAYS AS IDENTITY,
    action VARCHAR2(10),
    student_id NUMBER,
    old_name VARCHAR2(100),
    new_name VARCHAR2(100),
    old_group_id NUMBER,
    new_group_id NUMBER,
    action_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);


CREATE OR REPLACE TRIGGER students_log_trigger
AFTER INSERT OR UPDATE OR DELETE ON STUDENTS
FOR EACH ROW
DECLARE
    v_action VARCHAR2(10);
BEGIN
    IF INSERTING THEN
        v_action := 'INSERT';
    ELSIF UPDATING THEN
        v_action := 'UPDATE';
    ELSIF DELETING THEN
        v_action := 'DELETE';
    END IF;

    IF INSERTING OR UPDATING THEN
        INSERT INTO STUDENTS_LOG (action, student_id, old_name, new_name, old_group_id, new_group_id)
        VALUES (v_action, :NEW.Id, :OLD.Name, :NEW.Name, :OLD.Group_id, :NEW.Group_id);
    ELSE
        INSERT INTO STUDENTS_LOG (action, student_id, old_name, old_group_id)
        VALUES (v_action, :OLD.Id, :OLD.Name, :OLD.Group_id);
    END IF;
END;
/

INSERT INTO STUDENTS (Name, Group_id) VALUES ('John Doe', 1);
UPDATE STUDENTS SET Name = 'Jane Doe' WHERE Id = 64;
DELETE FROM STUDENTS WHERE Id = 64;
SELECT * FROM STUDENTS_LOG;

***********************************************************************************************************************

5:

CREATE OR REPLACE PROCEDURE restore_students_data (
    p_timestamp TIMESTAMP,
    p_offset INTERVAL DAY TO SECOND
) AS
BEGIN
    FOR log_rec IN (
        SELECT *
        FROM STUDENTS_LOG
        WHERE action_date <= p_timestamp
          AND action_date >= p_timestamp - p_offset
        ORDER BY action_date DESC
    ) LOOP
        IF log_rec.action = 'INSERT' THEN
            INSERT INTO STUDENTS (Id, Name, Group_id)
            VALUES (log_rec.student_id, log_rec.new_name, log_rec.new_group_id);
        ELSIF log_rec.action = 'UPDATE' THEN
            UPDATE STUDENTS
            SET Name = log_rec.new_name,
                Group_id = log_rec.new_group_id
            WHERE Id = log_rec.student_id;
        ELSIF log_rec.action = 'DELETE' THEN
            DELETE FROM STUDENTS
            WHERE Id = log_rec.student_id;
        END IF;
    END LOOP;
    
    COMMIT;
END;
/


BEGIN
    restore_students_data(TO_TIMESTAMP('2024-03-17 16:59:18', 'YYYY-MM-DD HH24:MI:SS'), INTERVAL '1' DAY);
END;
/

select * from students;

***********************************************************************************************************************

6:


CREATE OR REPLACE TRIGGER update_groups_cval
AFTER INSERT OR UPDATE OR DELETE ON STUDENTS
FOR EACH ROW
DECLARE
    v_student_count NUMBER;
BEGIN
    IF DELETING THEN
        -- Уменьшаем количество студентов в группе при удалении студента
UPDATE groups
    SET
      c_val = c_val - 1
    WHERE
      id = :old.gr_id;
    ELSIF INSERTING OR UPDATING THEN
        -- Увеличиваем количество студентов в группе при вставке или обновлении студента
        SELECT COUNT(*)
        INTO v_student_count
        FROM STUDENTS
        WHERE Group_id = :NEW.Group_id;

        -- Обновляем значение C_VAL в таблице GROUPS
        UPDATE GROUPS
        SET c_val = v_student_count + 1
        WHERE ID = :NEW.Group_id;
    END IF;
END;
/


INSERT INTO STUDENTS (Name, Group_id) VALUES ('ddd', 1);

select * from students;
select * from groups;


***********************************************************************************************************************
***********************************************************************************************************************
***********************************************************************************************************************

LAB_03:

--одинаковые таблицы
CREATE TABLE Dev.Table1 (
    id NUMBER PRIMARY KEY,
);

CREATE TABLE Prod.Table1 (
    id NUMBER PRIMARY KEY,
);

CREATE TABLE Dev.Table2 (
    id NUMBER PRIMARY KEY,
    value VARCHAR2(100)
);


--есть в dev но нет в prod
CREATE TABLE dev.Table4 (
    id NUMBER PRIMARY KEY,
    count number
);


--отличаются кол-вом столбцов
CREATE TABLE DEV.EMPLOYEES (
    EMPLOYEE_ID NUMBER PRIMARY KEY,
    FIRST_NAME VARCHAR2(50),
    LAST_NAME VARCHAR2(50),
    EMAIL VARCHAR2(100),
    HIRE_DATE DATE,
    SALARY NUMBER
);

CREATE TABLE PROD.EMPLOYEES (
    EMPLOYEE_ID NUMBER PRIMARY KEY,
    FULL_NAME VARCHAR2(100),
    EMAIL_ADDRESS VARCHAR2(100),
    HIRE_DATE DATE,
    SALARY NUMBER
);

--отличаются названием стоблца

CREATE TABLE DEV.PERSON (
    ID NUMBER PRIMARY KEY,
    FIRST_NAME VARCHAR2(50),
    SALARY NUMBER
);

CREATE TABLE PROD.PERSON (
    ID NUMBER PRIMARY KEY,
    FULL_NAME VARCHAR2(100),
    SALARY NUMBER
);

--отличаются типом стоблца

CREATE TABLE DEV.EMPLOYEES1 (
    ID NUMBER PRIMARY KEY,
    FULL_NAME VARCHAR(100),
    SALARY NUMBER
);

CREATE TABLE PROD.EMPLOYEES1 (
    ID NUMBER PRIMARY KEY,
    FULL_NAME VARCHAR2(100),
    SALARY DATE
);



--циклические зависимости(и в прод и в дэв)
CREATE TABLE Table_A (
    id NUMBER PRIMARY KEY,
    name VARCHAR2(100)
);

CREATE TABLE Table_B (
    id NUMBER PRIMARY KEY,
    name VARCHAR2(100),
    table_a_id NUMBER,
    CONSTRAINT fk_table_a_id FOREIGN KEY (table_a_id) REFERENCES Table_A(id)
);

CREATE TABLE Table_C (
    id NUMBER PRIMARY KEY,
    name VARCHAR2(100),
    table_b_id NUMBER,
    CONSTRAINT fk_table_b_id FOREIGN KEY (table_b_id) REFERENCES Table_B(id)
);

ALTER TABLE Table_A
ADD CONSTRAINT fk_table_c_id FOREIGN KEY (id) REFERENCES Table_C(id);



--скирпт сравнения таблиц

CREATE OR REPLACE NONEDITIONABLE PROCEDURE compare_schemas (
    dev_user_name IN VARCHAR2,
    prod_user_name IN VARCHAR2
) AS
    v_dev_table_name VARCHAR2(100);
    v_prod_table_name VARCHAR2(100);
    v_dev_columns VARCHAR2(4000);
    v_prod_columns VARCHAR2(4000);
BEGIN
    FOR dev_table_rec IN (SELECT table_name FROM all_tables WHERE owner = dev_user_name) LOOP
        v_dev_table_name := dev_table_rec.table_name;
        
        -- Получаем список имен столбцов и их типов данных в таблице DEV_USER
        SELECT LISTAGG(column_name || ' ' || data_type || CASE WHEN data_length IS NOT NULL THEN '(' || data_length || ')' ELSE '' END, ', ') WITHIN GROUP (ORDER BY column_id)
        INTO v_dev_columns
        FROM all_tab_columns
        WHERE owner = dev_user_name
        AND table_name = v_dev_table_name;
        
        -- Проверяем, существует ли таблица в схеме PROD_USER
        BEGIN
            SELECT table_name
            INTO v_prod_table_name
            FROM all_tables
            WHERE owner = prod_user_name
            AND table_name = v_dev_table_name;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                -- Если таблицы нет в схеме продакшена, выводим код ее создания
                DBMS_OUTPUT.PUT_LINE('Table ' || v_dev_table_name || ' is missing in ' || prod_user_name || ' schema. Creating...');
                DBMS_OUTPUT.PUT_LINE('CREATE TABLE ' || prod_user_name || '.' || v_dev_table_name || ' (' || v_dev_columns || ');');
                CONTINUE;
        END;
        
        -- Получаем список имен столбцов и их типов данных в соответствующей таблице PROD_USER
        SELECT LISTAGG(column_name || ' ' || data_type || CASE WHEN data_length IS NOT NULL THEN '(' || data_length || ')' ELSE '' END, ', ') WITHIN GROUP (ORDER BY column_id)
        INTO v_prod_columns
        FROM all_tab_columns
        WHERE owner = prod_user_name
        AND table_name = v_dev_table_name;
        
        -- Сравниваем списки имен столбцов и их типов данных
        IF v_dev_columns <> v_prod_columns THEN
            -- Выводим код для изменения структуры таблицы в PROD_USER
            DBMS_OUTPUT.PUT_LINE('Table ' || v_dev_table_name || ' structure differs in ' || prod_user_name || ' schema. Modifying...');
            DBMS_OUTPUT.PUT_LINE('ALTER TABLE ' || prod_user_name || '.' || v_dev_table_name || ' (' || v_dev_columns || ');');
        ELSE
            DBMS_OUTPUT.PUT_LINE('Table ' || v_dev_table_name || ' has the same structure in both schemas.');
        END IF;
    END LOOP;
END;


-- одинаковые процедуры

CREATE OR REPLACE PROCEDURE hello_world AS
BEGIN
    DBMS_OUTPUT.PUT_LINE('Hello world from schema!');
END hello_world;


-- только в дэв
CREATE OR REPLACE PROCEDURE procedure1 AS
BEGIN
    DBMS_OUTPUT.PUT_LINE('Hello world from schema!');
END hello_world;



--ращличные структуры
CREATE OR REPLACE PROCEDURE calculate_salary AS
BEGIN
    DBMS_OUTPUT.PUT_LINE('Salary calculated in prod schema');
        DBMS_OUTPUT.PUT_LINE('Salary calculated in prod schema');

END calculate_salary;

CREATE OR REPLACE PROCEDURE calculate_salary AS
BEGIN
    DBMS_OUTPUT.PUT_LINE('Salary calculated in prod dev');

END calculate_salary;


--процедуры с различными параметрами

CREATE OR REPLACE PROCEDURE procedure2 (
    p1 IN VARCHAR2,
    p2 IN VARCHAR2
) AS
BEGIN
    DBMS_OUTPUT.PUT_LINE('Parameter 1: ' || p1);
    DBMS_OUTPUT.PUT_LINE('Parameter 2: ' || p2);
END procedure2;


CREATE OR REPLACE PROCEDURE procedure2 (
    param1 IN VARCHAR2,
    param2 IN VARCHAR2
) AS
BEGIN
    DBMS_OUTPUT.PUT_LINE('Parameter 1: ' || param1);
    DBMS_OUTPUT.PUT_LINE('Parameter 2: ' || param2);
END procedure2;


--скрипт сравнеия процедур

create or replace NONEDITIONABLE PROCEDURE compare_procedures (
    dev_user_name IN VARCHAR2,
    prod_user_name IN VARCHAR2
) AS
    v_dev_procedure_name VARCHAR2(100);
    v_dev_procedure_body CLOB;
    v_prod_procedure_body CLOB;
BEGIN
    FOR dev_procedure_rec IN (
        SELECT object_name
        FROM all_objects
        WHERE owner = dev_user_name
        AND object_type = 'PROCEDURE'
    ) LOOP
        v_dev_procedure_name := dev_procedure_rec.object_name;
        
        -- Получаем тело процедуры из схемы DEV_USER
        SELECT LISTAGG(TEXT, CHR(10)) WITHIN GROUP (ORDER BY LINE) 
        INTO v_dev_procedure_body
        FROM ALL_SOURCE
        WHERE OWNER = dev_user_name
        AND NAME = v_dev_procedure_name
        AND TYPE = 'PROCEDURE';
        
        -- Получаем тело процедуры из схемы PROD_USER
        BEGIN
            SELECT LISTAGG(TEXT, CHR(10)) WITHIN GROUP (ORDER BY LINE) 
            INTO v_prod_procedure_body
            FROM ALL_SOURCE
            WHERE OWNER = prod_user_name
            AND NAME = v_dev_procedure_name
            AND TYPE = 'PROCEDURE';
            
            -- Сравниваем тела процедур
   
            IF v_prod_procedure_body IS NOT NULL THEN
                IF v_dev_procedure_body = v_prod_procedure_body THEN
                    DBMS_OUTPUT.PUT_LINE('Procedure ' || v_dev_procedure_name || ' is in both schemas.');
                ELSE
                    DBMS_OUTPUT.PUT_LINE('Procedure ' || v_dev_procedure_name || ' differs from ' || prod_user_name || ' schema.');
                    DBMS_OUTPUT.PUT_LINE('ALTER ' || v_dev_procedure_body);

                    -- Дополнительная логика для вывода различий, если это необходимо
                END IF;
            ELSE
                DBMS_OUTPUT.PUT_LINE('Procedure ' || v_dev_procedure_name || ' is missing in ' || prod_user_name || ' schema.');
                DBMS_OUTPUT.PUT_LINE('CREATE OR REPLACE ' || v_dev_procedure_body);
           
           
            END IF;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                DBMS_OUTPUT.PUT_LINE('Procedure ' || v_dev_procedure_name || ' is missing in ' || prod_user_name || ' schema.');
                DBMS_OUTPUT.PUT_LINE('CREATE OR REPLACE ' || v_dev_procedure_body);
                DBMS_OUTPUT.PUT_LINE('DROP PROCEDURE ' || v_dev_procedure_name || ';');

        END;
    END LOOP;
END;

--одинаковые функции

CREATE OR REPLACE FUNCTION calculate_sum_dev (x NUMBER, y NUMBER) RETURN NUMBER AS
BEGIN
    RETURN x + y;
END calculate_sum_dev;

--нет в прод но есть в дэв

CREATE OR REPLACE FUNCTION calculate_trio (x NUMBER, y NUMBER, z NUMBER) RETURN NUMBER AS
BEGIN
    RETURN (x * y * z);
END calculate_trio;

--различная структура

--дэв
CREATE OR REPLACE FUNCTION calculate_avg(x NUMBER, y NUMBER) RETURN NUMBER AS
BEGIN
    RETURN (x + y) / 2;
END calculate_avg_dev;

CREATE OR REPLACE FUNCTION calculate_smth (x NUMBER) RETURN NUMBER AS
BEGIN
    RETURN (x);
END calculate_smth;

--прод
CREATE OR REPLACE FUNCTION calculate_avg_dev (x NUMBER, y NUMBER) RETURN NUMBER AS
BEGIN
    RETURN (x + y) / 3;
END calculate_avg_dev;


CREATE OR REPLACE FUNCTION calculate_smth (y NUMBER) RETURN NUMBER AS
BEGIN
    RETURN (y);
END calculate_smth;

--скрипт сравнения функций
create or replace NONEDITIONABLE PROCEDURE compare_functions (
    dev_user_name IN VARCHAR2,
    prod_user_name IN VARCHAR2
) AS
    v_dev_function_name VARCHAR2(100);
    v_dev_function_body CLOB;
    v_prod_function_body CLOB;
BEGIN
    FOR dev_function_rec IN (
        SELECT object_name
        FROM all_objects
        WHERE owner = dev_user_name
        AND object_type = 'FUNCTION'
    ) LOOP
        v_dev_function_name := dev_function_rec.object_name;

        -- Получаем тело функции из схемы DEV_USER
        SELECT LISTAGG(TEXT, CHR(10)) WITHIN GROUP (ORDER BY LINE) 
        INTO v_dev_function_body
        FROM ALL_SOURCE
        WHERE OWNER = dev_user_name
        AND NAME = v_dev_function_name
        AND TYPE = 'FUNCTION';

        -- Получаем тело функции из схемы PROD_USER
        BEGIN
            SELECT LISTAGG(TEXT, CHR(10)) WITHIN GROUP (ORDER BY LINE) 
            INTO v_prod_function_body
            FROM ALL_SOURCE
            WHERE OWNER = prod_user_name
            AND NAME = v_dev_function_name
            AND TYPE = 'FUNCTION';

            -- Сравниваем тела функций
            IF v_prod_function_body IS NOT NULL THEN
                IF v_dev_function_body = v_prod_function_body THEN
                    DBMS_OUTPUT.PUT_LINE('Function ' || v_dev_function_name || ' is in both schemas.');
                ELSE
                    DBMS_OUTPUT.PUT_LINE('Function ' || v_dev_function_name || ' differs from ' || prod_user_name || ' schema.');
                    DBMS_OUTPUT.PUT_LINE('ALTER ' || v_dev_function_body);
                    -- Дополнительная логика для вывода различий, если это необходимо
                END IF;
            ELSE
                DBMS_OUTPUT.PUT_LINE('CREATE OR REPLACE ' || v_dev_function_body);
                DBMS_OUTPUT.PUT_LINE('Function ' || v_dev_function_name || ' is missing in ' || prod_user_name || ' schema.');
            END IF;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                DBMS_OUTPUT.PUT_LINE('CREATE OR REPLACE ' || v_dev_function_body);
                DBMS_OUTPUT.PUT_LINE('Function ' || v_dev_function_name || ' is missing in ' || prod_user_name || ' schema.');
                DBMS_OUTPUT.PUT_LINE('DROP FUNCTION ' || v_dev_function_name || ';');

        END;
    END LOOP;
END;

--одинаковые индексы

CREATE INDEX idx_user ON table2 (value);

--отличаются таблицы

--дэв
CREATE INDEX idx_b ON b (value);

--прод
CREATE INDEX idx_b ON с (value);

--отличаются столбцы

--дэв
CREATE INDEX idx_employees ON employees (email, salary);

--прод

CREATE INDEX idx_employees ON employees (salary);


--скрипт сравнения индексов

CREATE OR REPLACE NONEDITIONABLE PROCEDURE compare_indexes (
    dev_user_name IN VARCHAR2,
    prod_user_name IN VARCHAR2
) AS
    v_dev_index_name VARCHAR2(100);
    v_dev_index_table VARCHAR2(100);
    v_dev_index_columns VARCHAR2(4000);
    v_prod_index_count NUMBER;
    v_diff_count NUMBER;
BEGIN
    -- Проверяем индексы из схемы DEV_USER
    FOR dev_index_rec IN (
        SELECT i.index_name, i.table_name
        FROM all_indexes i
        WHERE i.owner = dev_user_name
    ) LOOP
        -- Получаем имя индекса и имя таблицы из курсора
        v_dev_index_name := dev_index_rec.index_name;
        v_dev_index_table := dev_index_rec.table_name;

        -- Получаем список столбцов для данного индекса из схемы DEV_USER
        SELECT LISTAGG(ic.column_name, ',') WITHIN GROUP (ORDER BY ic.column_position)
        INTO v_dev_index_columns
        FROM all_ind_columns ic
        WHERE ic.index_owner = dev_user_name
        AND ic.index_name = v_dev_index_name
        AND ic.table_name = v_dev_index_table;

        -- Проверяем, существует ли индекс в схеме PROD_USER
        BEGIN
            SELECT COUNT(*)
            INTO v_prod_index_count
            FROM all_indexes
            WHERE owner = prod_user_name
            AND index_name = v_dev_index_name
            AND table_name = v_dev_index_table;

            IF v_prod_index_count = 0 THEN
                -- Если индекса нет в прод, добавляем его
                DBMS_OUTPUT.PUT_LINE('Index ' || v_dev_index_name || ' for table ' || v_dev_index_table || ' is missing in ' || prod_user_name || ' schema.');
                DBMS_OUTPUT.PUT_LINE('CREATE INDEX ' || prod_user_name || '.' || v_dev_index_name || ' ON ' || prod_user_name || '.' || v_dev_index_table || ' (' || v_dev_index_columns || ');');
            ELSE
                -- Если индекс существует, получаем список столбцов из схемы PROD_USER
                SELECT COUNT(*)
                INTO v_diff_count
                FROM all_ind_columns
                WHERE index_owner = prod_user_name
                AND index_name = v_dev_index_name
                AND table_name = v_dev_index_table
                AND (SELECT LISTAGG(column_name, ',') WITHIN GROUP (ORDER BY column_position)
                     FROM all_ind_columns
                     WHERE index_owner = prod_user_name
                     AND index_name = v_dev_index_name
                     AND table_name = v_dev_index_table) = v_dev_index_columns;

                IF v_diff_count = 0 THEN
                    -- Если индекс существует и совпадает с версией в DEV, ничего не делаем
                    DBMS_OUTPUT.PUT_LINE('Index ' || v_dev_index_name || ' for table ' || v_dev_index_table || ' is in both schemas.');
                ELSE
                    -- Если индекс существует, но отличается от версии в DEV, изменяем его
                    DBMS_OUTPUT.PUT_LINE('Index ' || v_dev_index_name || ' for table ' || v_dev_index_table || ' differs from ' || prod_user_name || ' schema.');
                    DBMS_OUTPUT.PUT_LINE('ALTER INDEX ' || prod_user_name || '.' || v_dev_index_name || ' REBUILD;');
                END IF;
            END IF;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                -- Если индекса нет в прод, добавляем его
                DBMS_OUTPUT.PUT_LINE('Index ' || v_dev_index_name || ' for table ' || v_dev_index_table || ' is missing in ' || prod_user_name || ' schema.');
                DBMS_OUTPUT.PUT_LINE('CREATE INDEX ' || prod_user_name || '.' || v_dev_index_name || ' ON ' || prod_user_name || '.' || v_dev_index_table || ' (' || v_dev_index_columns || ');');
        END;
    END LOOP;
END;


--одинаковые пакеты

CREATE OR REPLACE PACKAGE dev_package AS
    PROCEDURE procedure1;
END dev_package;
/

CREATE OR REPLACE PACKAGE BODY dev_package AS
    PROCEDURE procedure1 IS
    BEGIN
        NULL;
    END procedure1;
END dev_package;
/

--пакеты с различной структурой(телом)

--дэв
CREATE OR REPLACE PACKAGE package2 AS
    PROCEDURE procedure1;
END package2;
/

CREATE OR REPLACE PACKAGE BODY package2 AS
    PROCEDURE procedure1 IS
    BEGIN
        NULL;
    END procedure1;

    PROCEDURE procedure2 IS
    BEGIN
        NULL;
    END procedure2;
END package2;

--прод

CREATE OR REPLACE PACKAGE package2 AS
    PROCEDURE procedure1;
END package2;
/

CREATE OR REPLACE PACKAGE BODY package2 AS
    PROCEDURE procedure1 IS
    BEGIN
        NULL;
    END procedure1;
END package2;
/


--скрипт сравнения пакетов

CREATE OR REPLACE PROCEDURE compare_packages (
    dev_user_name IN VARCHAR2,
    prod_user_name IN VARCHAR2
) AS
    v_dev_package_name VARCHAR2(100);
    v_dev_package_spec CLOB;
    v_dev_package_body CLOB;
    v_prod_package_spec CLOB;
    v_prod_package_body CLOB;
BEGIN
    FOR dev_package_rec IN (
        SELECT object_name
        FROM all_objects
        WHERE owner = dev_user_name
        AND object_type = 'PACKAGE'
    ) LOOP
        v_dev_package_name := dev_package_rec.object_name;

        -- Получаем спецификацию пакета из схемы DEV_USER
        SELECT LISTAGG(TEXT, CHR(10)) WITHIN GROUP (ORDER BY LINE) 
        INTO v_dev_package_spec
        FROM ALL_SOURCE
        WHERE OWNER = dev_user_name
        AND NAME = v_dev_package_name
        AND TYPE = 'PACKAGE'
        AND LINE <= (SELECT MIN(LINE) FROM ALL_SOURCE WHERE OWNER = dev_user_name AND NAME = v_dev_package_name AND TYPE = 'PACKAGE BODY');

        -- Получаем тело пакета из схемы DEV_USER
        SELECT LISTAGG(TEXT, CHR(10)) WITHIN GROUP (ORDER BY LINE) 
        INTO v_dev_package_body
        FROM ALL_SOURCE
        WHERE OWNER = dev_user_name
        AND NAME = v_dev_package_name
        AND TYPE = 'PACKAGE BODY';

        -- Получаем спецификацию пакета из схемы PROD_USER
        BEGIN
            SELECT LISTAGG(TEXT, CHR(10)) WITHIN GROUP (ORDER BY LINE) 
            INTO v_prod_package_spec
            FROM ALL_SOURCE
            WHERE OWNER = prod_user_name
            AND NAME = v_dev_package_name
            AND TYPE = 'PACKAGE'
            AND LINE <= (SELECT MIN(LINE) FROM ALL_SOURCE WHERE OWNER = prod_user_name AND NAME = v_dev_package_name AND TYPE = 'PACKAGE BODY');

            -- Получаем тело пакета из схемы PROD_USER
            SELECT LISTAGG(TEXT, CHR(10)) WITHIN GROUP (ORDER BY LINE) 
            INTO v_prod_package_body
            FROM ALL_SOURCE
            WHERE OWNER = prod_user_name
            AND NAME = v_dev_package_name
            AND TYPE = 'PACKAGE BODY';

            -- Сравниваем спецификации и тела пакетов
            IF v_prod_package_spec IS NOT NULL AND v_prod_package_body IS NOT NULL THEN
                IF v_dev_package_spec = v_prod_package_spec AND v_dev_package_body = v_prod_package_body THEN
                    DBMS_OUTPUT.PUT_LINE('Package ' || v_dev_package_name || ' is in both schemas.');
                ELSE
                    DBMS_OUTPUT.PUT_LINE('Package ' || v_dev_package_name || ' differs from ' || prod_user_name || ' schema.');

                    -- Код для изменения пакета в PROD в соответствии с DEV
                    DBMS_OUTPUT.PUT_LINE('/* SQL code to modify the package in ' || prod_user_name || ' schema based on ' || dev_user_name || ' schema */');
                    DBMS_OUTPUT.PUT_LINE('CREATE OR REPLACE ' || v_dev_package_spec);
                    DBMS_OUTPUT.PUT_LINE('/');
                    DBMS_OUTPUT.PUT_LINE('CREATE OR REPLACE ' || v_dev_package_body);
                    DBMS_OUTPUT.PUT_LINE('/');

                END IF;
            ELSE
                DBMS_OUTPUT.PUT_LINE('Package ' || v_dev_package_name || ' is missing in ' || prod_user_name || ' schema.');

                -- Код для добавления пакета в PROD из DEV
                DBMS_OUTPUT.PUT_LINE('/* SQL code to add the package to ' || prod_user_name || ' schema from ' || dev_user_name || ' schema */');
                DBMS_OUTPUT.PUT_LINE('CREATE OR REPLACE ' || v_dev_package_spec);
                DBMS_OUTPUT.PUT_LINE('/');
                DBMS_OUTPUT.PUT_LINE('CREATE OR REPLACE ' || v_dev_package_body);
                DBMS_OUTPUT.PUT_LINE('/');

            END IF;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                DBMS_OUTPUT.PUT_LINE('Package ' || v_dev_package_name || ' is missing in ' || prod_user_name || ' schema.');

                -- Код для удаления пакета из PROD, если он есть в PROD, но отсутствует в DEV
                DBMS_OUTPUT.PUT_LINE('DROP PACKAGE ' || v_dev_package_name || ';');
                DBMS_OUTPUT.PUT_LINE('/');
     END;
    END LOOP;
END;

***********************************************************************************************************************
***********************************************************************************************************************
***********************************************************************************************************************

LAB_04:


----------------------------------------------------------------------------------
DECLARE
    v_json_data CLOB := '
{
    "type": "SELECT",
    "columns": ["employee.name, salary"],
    "tables": ["employee"],
    "filter_type": "no subquery",
    "filter_conditions": "employee.salary > 50000",
    "join_conditions": {
            "type": "inner",
            "table": "department",
            "condition": "employee.department_id = department.department_id"
            },  	

}



    ';
BEGIN
    execute_dynamic_query(v_json_data);
END;


SELECT employee.name, salary 
FROM employee 
INNER JOIN department 
ON employee.department_id = department.department_id 
AND employee.salary > 50000


----------------------------------------------------------------------------------
--ПРИМЕР с IN
{
    "type": "SELECT",
    "columns": ["employee.name, salary"],
    "tables": ["employee"],
    "filter_type": "subquery",
    "condition_type": "in",
    "in_expression" : "employee.name",
    "filter_conditions": {
        "subquery_columns": "employee.name",
        "subquery_tables": ["employee"],
        "subquery_join_conditions": {
            "type": "inner",
            "table": "department",
            "condition": " employee.department_id = department.department_id"
        },  	
        "subquery_filter_conditions" : "employee.salary > 50000"
    }
}

SELECT employee.name, salary
FROM employee
WHERE employee.name in
        (SELECT employee.name FROM employee
        INNER JOIN department 
        ON employee.department_id = department.department_id 
        AND employee.salary > 50000)


--ПРИМЕР с exists

{
    "type": "SELECT",
    "columns": "*",
    "tables": ["customers"],
    "filter_type": "subquery",
    "condition_type": "exists",
    "filter_conditions": {
        "subquery_columns": "*",
        "subquery_tables": ["orders"],
        "subquery_filter_conditions" : "customers.customer_id = orders.customer_id"
    }
}


----------------------------------------------------------------------------------
{
    "type": "DELETE",
    "tables": ["a"],
    "filter_type": "no subquery",
    "condition_type": "exists",
    "in_expression": "",
    "filter_conditions": "a.col1 = 6"

}


 DELETE FROM a
 WHERE a.col1 = 6


{
    "type": "DELETE",
    "tables": ["a"],
    "filter_type": "subquery",
    "condition_type": "exists",
    "in_expression": "",
    "filter_conditions": {
        "subquery_columns": "",
        "subquery_tables": ["a"],
     
        "subquery_filter_conditions" : "a.col1 = 1"
    }


 DELETE FROM a
 WHERE EXISTS
	 (SELECT *
	 FROM a
	 WHERE a.col1 = 1)


{
    "type": "INSERT",
    "tables": ["project"],
    "columns": ["project_id", "project_name", "project_description"],
    "values": [101, "New Project", "Description of the new project"],
    "filter_type": "no subquery",
}

INSERT INTO project (project_id, project_name, project_description)
VALUES
('101', 'New Project', 'Description of the new project')



{
    "type": "INSERT",
    "tables": ["a"],
    "columns": ["id", "col1", "col2"],
    "values": [11, 11, 11],
    "filter_type": "subquery",
    "filter_conditions": {
        "subquery_columns": "",
        "subquery_tables": ["a"],
     
        "subquery_filter_conditions" : "a.col1 = 1"
    }

}

INSERT INTO a (id, col1, col2)
	 SELECT *
	 FROM a
	 WHERE a.col1 = 1


{
    "type": "UPDATE",
    "tables": ["a"],
    "update_columns": [
        {"column_name": "col1", "expression": "111"},
        {"column_name": "col2", "expression": "222"},
    ],

        "filter_type": "no subquery",

    "filter_conditions": "a.col1 = 1"

}

UPDATE a
 SET col1 = 111, 
	col2 = 222 WHERE a.id = 1



----------------------------------------------------------------------------------
CREATE OR REPLACE NONEDITIONABLE PROCEDURE execute_dynamic_query (json_data IN CLOB) AS
    v_type VARCHAR2(10);
    v_query VARCHAR2(10000);
    
    v_columns VARCHAR2(4000);
    v_values VARCHAR2(4000); -- Добавлено для значений при INSERT
    v_tables VARCHAR2(4000);
    v_join_conditions VARCHAR2(4000);
    v_join_type VARCHAR2(10);
    v_join_table VARCHAR2(100);
    v_filter_conditions VARCHAR2(4000);

    v_condition_type VARCHAR2(4000);
    v_in_expression VARCHAR2(4000);
    v_filter_type VARCHAR2(4000);
 
    v_subquery_columns VARCHAR2(4000);
    v_subquery_tables VARCHAR2(4000);
    v_subquery_join_conditions VARCHAR2(4000);
    v_subquery_join_table VARCHAR2(4000);
    v_subquery_join_type VARCHAR2(4000);
    v_subquery_filter_conditions VARCHAR2(4000);
BEGIN
    -- Парсинг JSON
    v_type := JSON_VALUE(json_data, '$.type');
    
    SELECT LISTAGG(column_name, ', ') WITHIN GROUP (ORDER BY rn) INTO v_columns
    FROM JSON_TABLE(json_data, '$.columns[*]' COLUMNS rn FOR ORDINALITY, column_name VARCHAR2(100) PATH '$');

    
    
    -- Преобразуем JSON-массив в строку и удалим кавычки
    SELECT LISTAGG(table_name, ', ') WITHIN GROUP (ORDER BY rn) INTO v_tables
    FROM JSON_TABLE(json_data, '$.tables[*]' COLUMNS rn FOR ORDINALITY, table_name VARCHAR2(100) PATH '$');

    v_join_type := JSON_VALUE(json_data, '$.join_conditions.type');
    v_join_table := JSON_VALUE(json_data, '$.join_conditions.table');
    v_join_conditions := JSON_VALUE(json_data, '$.join_conditions.condition');

    v_condition_type := JSON_VALUE(json_data, '$.condition_type');
    v_in_expression := JSON_VALUE(json_data, '$.in_expression');
 
    v_filter_type := JSON_VALUE(json_data, '$.filter_type');

    IF v_filter_type = 'no subquery' THEN
        v_filter_conditions := JSON_VALUE(json_data, '$.filter_conditions');
    ELSIF v_filter_type = 'subquery' THEN
        v_subquery_columns := JSON_VALUE(json_data, '$.filter_conditions.subquery_columns');
        
        SELECT LISTAGG(table_name, ', ') WITHIN GROUP (ORDER BY rn) INTO v_subquery_tables
        FROM JSON_TABLE(json_data, '$.filter_conditions.subquery_tables[*]' COLUMNS rn FOR ORDINALITY, table_name VARCHAR2(100) PATH '$');
        
        v_subquery_join_conditions:= JSON_VALUE(json_data, '$.filter_conditions.subquery_join_conditions.condition');
        v_subquery_join_type := JSON_VALUE(json_data, '$.filter_conditions.subquery_join_conditions.type');
        v_subquery_join_table := JSON_VALUE(json_data, '$.filter_conditions.subquery_join_conditions.table');
        v_subquery_filter_conditions:= JSON_VALUE(json_data, '$.filter_conditions.subquery_filter_conditions');
    ELSE 
        RAISE_APPLICATION_ERROR(-20001, 'Incorrect filter_conditions type in JSON data.');
    END IF;

    -- Формирование SQL запроса
    IF v_type = 'SELECT' THEN
        v_query := 'SELECT ';
    ELSIF v_type = 'INSERT'  THEN
        v_query := 'INSERT INTO ' || v_tables || ' (' || v_columns || ')';
        IF v_filter_type = 'no subquery' THEN
        v_query := 'INSERT INTO ' || v_tables || ' (' || v_columns || ')' || CHR(10) || 'VALUES';
        -- Добавляем значения для INSERT
        
    SELECT LISTAGG('''' || value_name || '''', ', ') WITHIN GROUP (ORDER BY rn) INTO v_values
    FROM JSON_TABLE(json_data, '$.values[*]' COLUMNS rn FOR ORDINALITY, value_name VARCHAR2(100) PATH '$');


    
        v_values := '(' || v_values || ')';
        v_query := v_query || CHR(10) || v_values || CHR(10);
        END IF;
    ELSIF v_type = 'UPDATE' THEN
        v_query := 'UPDATE ';
    ELSIF v_type = 'DELETE' THEN
        v_query := 'DELETE ';
    ELSE
        RAISE_APPLICATION_ERROR(-20002, 'Invalid query type specified.');
    END IF;

    IF v_type IN ('SELECT', 'INSERT', 'UPDATE', 'DELETE') THEN
        IF v_type IN ('SELECT') THEN
            IF v_columns IS NOT NULL THEN
                v_query := v_query || v_columns || CHR(10);
            ELSE
                v_query := v_query || '*' || CHR(10);
            END IF;
        END IF;

        IF v_tables IS NULL THEN
            RAISE_APPLICATION_ERROR(-20003, 'No tables specified in JSON data.');
        ELSIF v_type NOT IN ('INSERT', 'UPDATE') THEN
            v_query := v_query || ' FROM ' || v_tables || CHR(10);
        END IF;

        IF v_join_type IS NOT NULL THEN
            IF v_join_type IN ('inner', 'outer', 'right', 'left', 'full') THEN
                v_query := v_query || ' ' || upper(v_join_type) || ' JOIN ' || v_join_table || CHR(10) || ' ON ' || v_join_conditions || CHR(10);
            ELSE
                RAISE_APPLICATION_ERROR(-20004, 'Invalid join type specified.');
            END IF;
        END IF;

        IF v_type IN ('SELECT', 'INSERT', 'UPDATE', 'DELETE') THEN
            -- Для запросов INSERT, UPDATE и DELETE добавляем условия фильтрации
            IF v_filter_type = 'no subquery' THEN
                IF v_filter_conditions IS NOT NULL THEN
                    IF v_type IN ('SELECT', 'UPDATE', 'DELETE') THEN
                    v_query := v_query || ' WHERE ' || v_filter_conditions || CHR(10);
                    ELSE
                    RAISE_APPLICATION_ERROR(-20005, 'Filter conditions required for UPDATE and DELETE queries.');
                    END IF;
                END IF;
            ELSIF v_filter_type = 'subquery' THEN
                
                
                IF v_type!='INSERT' THEN
                    v_query := v_query || ' WHERE ';
                    IF v_condition_type = 'in' THEN
                        v_query := v_query || v_in_expression || ' IN' || CHR(10);
                    ELSIF v_condition_type = 'not in' THEN
                        v_query := v_query || v_in_expression || ' NOT IN' || CHR(10);
                    ELSIF v_condition_type = 'exists' THEN
                        v_query := v_query || 'EXISTS' || CHR(10);
                    ELSIF v_condition_type = 'not exists' THEN
                        v_query := v_query || 'NOT EXISTS' || CHR(10);
                    ELSE
                        RAISE_APPLICATION_ERROR(-20006, 'Invalid condition type1.');
                    END IF;
                    v_query := v_query || CHR(9) || ' (SELECT ';
                ELSE v_query := v_query || CHR(10) || CHR(9) || ' SELECT ';
                END IF;
                
                
                IF v_subquery_columns IS NOT NULL THEN
                    v_query := v_query || v_subquery_columns || CHR(10);
                ELSE
                    v_query := v_query || '*' || CHR(10);
                END IF;
                
                IF v_subquery_tables IS NULL THEN
                    RAISE_APPLICATION_ERROR(-20007, 'No tables specified in subquery.');
                ELSE
                    v_query := v_query || CHR(9) || ' FROM ' || v_subquery_tables || CHR(10);
                END IF;
                
                IF v_subquery_join_type IS NOT NULL THEN
                    IF v_subquery_join_type IN ('inner', 'outer', 'right', 'left', 'full') THEN
                        v_query := v_query || CHR(9) || ' ' || UPPER(v_subquery_join_type) || ' JOIN ' || v_subquery_join_table || CHR(10) || CHR(9) || ' ON ' || v_subquery_join_conditions || CHR(10);
                    ELSE
                        RAISE_APPLICATION_ERROR(-20008, 'Invalid join type specified in subquery.');
                    END IF;
                END IF;
                
                IF v_subquery_filter_conditions IS NOT NULL THEN
                    IF v_subquery_join_conditions IS NOT NULL THEN
                        v_query := v_query || CHR(9) || ' AND ' || v_subquery_filter_conditions;
                    ELSE
                        v_query := v_query || CHR(9) || ' WHERE ' || v_subquery_filter_conditions;
                    END IF;
                END IF;
                IF v_type!='INSERT' THEN
                     v_query := v_query || ')';
                END IF;
            ELSE 
                RAISE_APPLICATION_ERROR(-20009, 'Incorrect filter conditions type in JSON data.');
            END IF;
        END IF;
    END IF;

    -- Вывод сформированного запроса
    DBMS_OUTPUT.PUT_LINE('Generated Query: ' || CHR(10) || v_query || CHR(10) );

    -- Выполнение SQL запроса
    --EXECUTE IMMEDIATE v_query;
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('An error occurred: ' || SQLERRM);
END execute_dynamic_query;

-------------------------------------------------------------------------------------

4 и 5 задания

{
    "query_type": "CREATE TABLE",
    "table": "employees3",
    "columns": [
        {"name": "employee_id", "type": "NUMBER"},
        {"name": "first_name", "type": "VARCHAR2(50)"},
        {"name": "last_name", "type": "VARCHAR2(50)"},
        {"name": "department_id", "type": "NUMBER"}
    ],
    "primary_keys": ["employee_id"],
    "foreign_keys": [
        {"field": "department_id", "table": "departments", "ref_field": "department_id"}
    ]
}


CREATE TABLE employees3
 (
	employee_id NUMBER, 
	first_name VARCHAR2(50), 
	last_name VARCHAR2(50), 
	department_id NUMBER, 
	constraint pk_employees3_employee_id primary key (employee_id), 
	constraint fk_employees3_department_id FOREIGN KEY (department_id) REFERENCES department(department_id)
);

CREATE SEQUENCE employees3_seq start with 1;

CREATE OR REPLACE TRIGGER tr_employees3_pk_autoincrement
BEFORE INSERT ON employees3 FOR EACH ROW
BEGIN
  SELECT employees3_seq.NEXTVAL INTO :NEW.employee_id FROM DUAL;
END;



{
    "query_type": "DROP TABLE",
    "table": "employees3",
    
}

DROP TABLE employees3
---------------------------------------------------------------------------
CREATE OR REPLACE PROCEDURE generate_ddl(
    json_str CLOB
) AS
    v_query_type VARCHAR2(20);
    v_tables VARCHAR2(100);
    v_columns VARCHAR2(4000);
    v_pks VARCHAR2(4000);
    v_fks VARCHAR2(4000);
    v_trigger VARCHAR2(4000);
    v_drop_param VARCHAR2(20);
    v_sql VARCHAR2(4000);
    v_pk_column VARCHAR2(4000);
BEGIN
    -- Определяем тип операции
    v_query_type := json_value(json_str, '$.query_type');

    -- Создание таблицы
    IF v_query_type = 'CREATE TABLE' THEN
        -- Получаем имя таблицы
        SELECT json_value(json_str, '$.table') INTO v_tables FROM dual;

        -- Получаем столбцы таблицы
        SELECT LISTAGG(column_name || ' ' || data_type, ', '|| chr(10)|| chr(9)) WITHIN GROUP (ORDER BY column_id) INTO v_columns
        FROM JSON_TABLE(json_str, '$.columns[*]'
            COLUMNS (
                column_id FOR ORDINALITY,
                column_name VARCHAR2(100) PATH '$.name',
                data_type VARCHAR2(100) PATH '$.type'
            )
        );

        -- Получаем первичные ключи
               SELECT LISTAGG ('constraint pk_' || v_tables || '_' || col_name || ' primary key (' || col_name || ')', ', ') INTO v_pks
        FROM JSON_TABLE (json_str,
            '$.primary_keys[*]' COLUMNS (col_name VARCHAR2 (4000) PATH '$')) j;

        -- Получаем внешние ключи
        SELECT LISTAGG('constraint fk_' || v_tables || '_' || col_name || ' FOREIGN KEY (' || col_name || ') REFERENCES ' || ref_table || '(' || ref_field || ')', ', ') INTO v_fks
        FROM JSON_TABLE(json_str, '$.foreign_keys[*]'
            COLUMNS (
                col_name VARCHAR2(100) PATH '$.field',
                ref_table VARCHAR2(100) PATH '$.table',
                ref_field VARCHAR2(100) PATH '$.ref_field'
            )
        );

        -- Формируем DDL для создания таблицы
        v_sql := 'CREATE TABLE ' || v_tables || chr(10) ||
         ' (' || chr(10) ||
         chr(9) || v_columns  || ', ' || chr(10) ||
         chr(9) || v_pks || ', ' || chr(10) ||
         chr(9) || v_fks || chr(10) ||
         ');';

        -- Создание последовательности
        SELECT json_value(json_str, '$.primary_keys[0]') INTO v_pk_column
        FROM dual;
        
        -- Создание последовательности
        v_sql := v_sql || chr(10) || chr(10) || 'CREATE SEQUENCE ' || v_tables || '_seq START WITH 1;' || chr(10) || chr(10) || 
                 'CREATE OR REPLACE TRIGGER tr_' || v_tables  || '_pk_autoincrement' || chr(10) || 
                 'BEFORE INSERT ON ' || v_tables || 
                 ' FOR EACH ROW' || chr(10) ||
                 'BEGIN' || chr(10) ||
                 '  SELECT ' || v_tables || '_seq.NEXTVAL INTO :NEW.' || v_pk_column || ' FROM DUAL;' || chr(10) ||
                 'END;';

    -- Удаление таблицы
    ELSIF v_query_type = 'DROP TABLE' THEN
        -- Получаем имя таблицы для удаления
        SELECT json_value(json_str, '$.table') INTO v_tables FROM dual;

        -- Получаем параметр для удаления (пурж)
        v_drop_param := json_value(json_str, '$.parameters');

        -- Формируем DDL для удаления таблицы
        v_sql := 'DROP TABLE ' || v_tables;
        IF v_drop_param = 'purge' THEN
            v_sql := v_sql || ' PURGE';
        END IF;

    END IF;

    -- Выводим сгенерированный SQL
    DBMS_OUTPUT.PUT_LINE('Сгенерированный SQL:');
    DBMS_OUTPUT.PUT_LINE(v_sql);
END;


***********************************************************************************************************************
***********************************************************************************************************************
***********************************************************************************************************************

LAB_05:




